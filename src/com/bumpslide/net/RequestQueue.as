/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008, 2009 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */ package com.bumpslide.net {	import com.bumpslide.data.Action;	import com.bumpslide.data.ActionQueue;	import com.bumpslide.data.Callback;	import com.bumpslide.util.Delegate;		import flash.events.EventDispatcher;	import flash.utils.Dictionary;		/**	 * Prioritized and 'multi-threaded' loading queue for RPC requests	 * 	 * @author David Knape	 */	public class RequestQueue extends EventDispatcher {		private var _queue:ActionQueue;		private var _actions:Dictionary;				public var debugEnabled:Boolean = false;				private static const DEFAULT_THREAD_COUNT:uint = 1;		public function RequestQueue() {			_queue = new ActionQueue();			_queue.threads = DEFAULT_THREAD_COUNT;			_actions = new Dictionary(true);		}				public function clear() : void {			var req:IRPCRequest;			for( var o:Object in _actions) {				req = (o as IRPCRequest);				req.cancel();				remove(req);			}			_queue.clear();		}		public function load( req:IRPCRequest, priority:Number=1 ):void {						// remove existing			if(_actions[req]) remove( req );						debug('Enqueuing Request ' +req);			// create action			var a:Action=new Action(req.load, priority);			req.addResponder( 				new Callback(  					Delegate.create( handleResult, req ), 					Delegate.create( handleError, req ) 				) 			); 						// save reference to action so it can be cancelled using the req as a key			_actions[req] = a; 			_queue.enqueue(a);		}				protected function handleError( info:Object, req:IRPCRequest ):void {			debug('Error for ' +req);			remove( req );		}		protected function handleResult(result:Object, req:IRPCRequest):void {			debug('Got Result for ' +req);			remove( req );		}		protected function remove( req:IRPCRequest ):void {			if(req == null) return;			var a:Action=_actions[req];			_queue.remove(a);			delete _actions[req];		}				public function get threads():uint {			return _queue.threads;		}				public function set threads(threads:uint):void {			_queue.threads = threads;		}				public function get size():uint {			return _queue.size;		}				protected function debug( s:* ) : void {			if(debugEnabled) trace('[RequestQueue] ' + s );		}	}}